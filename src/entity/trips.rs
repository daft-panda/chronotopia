//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.8

use postgis::ewkb::{GeometryT, Point};
use sea_orm::entity::prelude::*;

#[derive(Copy, Clone, Default, Debug, DeriveEntity)]
pub struct Entity;

impl EntityName for Entity {
    fn table_name(&self) -> &str {
        "trips"
    }
}

#[derive(Clone, Debug, DeriveModel)]
pub struct Model {
    pub id: Uuid,
    pub user_id: Uuid,
    pub geometry: GeometryT<Point>,
    pub bounding_box: GeometryT<Point>,
    pub start_time: DateTimeWithTimeZone,
    pub end_time: DateTimeWithTimeZone,
    pub distance_meters: f64,
    pub points: Option<Vec<u8>>,
    pub processed: bool,
    pub osm_way_ids: Json,
    pub route_match_trace: Option<Vec<u8>>,
    pub label: Option<String>,
    pub notes: Option<String>,
    pub geo_json: Option<String>,
    pub last_modified: DateTimeWithTimeZone,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]
pub enum Column {
    Id,
    UserId,
    Geometry,
    BoundingBox,
    StartTime,
    EndTime,
    DistanceMeters,
    Points,
    Processed,
    OsmWayIds,
    RouteMatchTrace,
    Label,
    Notes,
    GeoJson,
    LastModified,
}

#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]
pub enum PrimaryKey {
    Id,
}

impl PrimaryKeyTrait for PrimaryKey {
    type ValueType = Uuid;
    fn auto_increment() -> bool {
        false
    }
}

#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {
    Users,
}

impl ColumnTrait for Column {
    type EntityName = Entity;
    fn def(&self) -> ColumnDef {
        match self {
            Self::Id => ColumnType::Uuid.def(),
            Self::UserId => ColumnType::Uuid.def(),
            Self::Geometry => ColumnType::custom("geometry").def(),
            Self::BoundingBox => ColumnType::custom("geometry").def(),
            Self::StartTime => ColumnType::TimestampWithTimeZone.def(),
            Self::EndTime => ColumnType::TimestampWithTimeZone.def(),
            Self::DistanceMeters => ColumnType::Double.def(),
            Self::Points => ColumnType::VarBinary(StringLen::None).def().null(),
            Self::Processed => ColumnType::Boolean.def(),
            Self::OsmWayIds => ColumnType::JsonBinary.def(),
            Self::RouteMatchTrace => ColumnType::VarBinary(StringLen::None).def().null(),
            Self::Label => ColumnType::String(StringLen::None).def().null(),
            Self::Notes => ColumnType::String(StringLen::None).def().null(),
            Self::GeoJson => ColumnType::String(StringLen::None).def().null(),
            Self::LastModified => ColumnType::TimestampWithTimeZone.def(),
        }
    }
}

impl RelationTrait for Relation {
    fn def(&self) -> RelationDef {
        match self {
            Self::Users => Entity::belongs_to(super::users::Entity)
                .from(Column::UserId)
                .to(super::users::Column::Id)
                .into(),
        }
    }
}

impl Related<super::users::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Users.def()
    }
}

pub struct ActiveModel {
    /// Generated by sea-orm-macros
    pub id: sea_orm::ActiveValue<Uuid>,
    /// Generated by sea-orm-macros
    pub user_id: sea_orm::ActiveValue<Uuid>,
    /// Generated by sea-orm-macros
    pub geometry: sea_orm::ActiveValue<GeometryT<Point>>,
    /// Generated by sea-orm-macros
    pub bounding_box: sea_orm::ActiveValue<GeometryT<Point>>,
    /// Generated by sea-orm-macros
    pub start_time: sea_orm::ActiveValue<DateTimeWithTimeZone>,
    /// Generated by sea-orm-macros
    pub end_time: sea_orm::ActiveValue<DateTimeWithTimeZone>,
    /// Generated by sea-orm-macros
    pub distance_meters: sea_orm::ActiveValue<f64>,
    /// Generated by sea-orm-macros
    pub points: sea_orm::ActiveValue<Option<Vec<u8>>>,
    /// Generated by sea-orm-macros
    pub processed: sea_orm::ActiveValue<bool>,
    /// Generated by sea-orm-macros
    pub osm_way_ids: sea_orm::ActiveValue<Json>,
    /// Generated by sea-orm-macros
    pub route_match_trace: sea_orm::ActiveValue<Option<Vec<u8>>>,
    /// Generated by sea-orm-macros
    pub label: sea_orm::ActiveValue<Option<String>>,
    /// Generated by sea-orm-macros
    pub notes: sea_orm::ActiveValue<Option<String>>,
    /// Generated by sea-orm-macros
    pub geo_json: sea_orm::ActiveValue<Option<String>>,
    /// Generated by sea-orm-macros
    pub last_modified: sea_orm::ActiveValue<DateTimeWithTimeZone>,
}
#[automatically_derived]
impl ::core::clone::Clone for ActiveModel {
    #[inline]
    fn clone(&self) -> ActiveModel {
        ActiveModel {
            id: ::core::clone::Clone::clone(&self.id),
            user_id: ::core::clone::Clone::clone(&self.user_id),
            geometry: ::core::clone::Clone::clone(&self.geometry),
            bounding_box: ::core::clone::Clone::clone(&self.bounding_box),
            start_time: ::core::clone::Clone::clone(&self.start_time),
            end_time: ::core::clone::Clone::clone(&self.end_time),
            distance_meters: ::core::clone::Clone::clone(&self.distance_meters),
            points: ::core::clone::Clone::clone(&self.points),
            processed: ::core::clone::Clone::clone(&self.processed),
            osm_way_ids: ::core::clone::Clone::clone(&self.osm_way_ids),
            route_match_trace: ::core::clone::Clone::clone(&self.route_match_trace),
            label: ::core::clone::Clone::clone(&self.label),
            notes: ::core::clone::Clone::clone(&self.notes),
            geo_json: ::core::clone::Clone::clone(&self.geo_json),
            last_modified: ::core::clone::Clone::clone(&self.last_modified),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for ActiveModel {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "id",
            "user_id",
            "geometry",
            "bounding_box",
            "start_time",
            "end_time",
            "distance_meters",
            "points",
            "processed",
            "osm_way_ids",
            "route_match_trace",
            "label",
            "notes",
            "geo_json",
            "last_modified",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &self.id,
            &self.user_id,
            &self.geometry,
            &self.bounding_box,
            &self.start_time,
            &self.end_time,
            &self.distance_meters,
            &self.points,
            &self.processed,
            &self.osm_way_ids,
            &self.route_match_trace,
            &self.label,
            &self.notes,
            &self.geo_json,
            &&self.last_modified,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(f, "ActiveModel", names, values)
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for ActiveModel {}
#[automatically_derived]
impl ::core::cmp::PartialEq for ActiveModel {
    #[inline]
    fn eq(&self, other: &ActiveModel) -> bool {
        self.id == other.id
            && self.user_id == other.user_id
            && self.start_time == other.start_time
            && self.end_time == other.end_time
            && self.distance_meters == other.distance_meters
            && self.points == other.points
            && self.processed == other.processed
            && self.osm_way_ids == other.osm_way_ids
            && self.route_match_trace == other.route_match_trace
            && self.label == other.label
            && self.notes == other.notes
            && self.geo_json == other.geo_json
            && self.last_modified == other.last_modified
    }
}
#[automatically_derived]
impl std::default::Default for ActiveModel {
    fn default() -> Self {
        <Self as sea_orm::ActiveModelBehavior>::new()
    }
}
#[automatically_derived]
impl std::convert::From<Model> for ActiveModel {
    fn from(m: Model) -> Self {
        Self {
            id: sea_orm::ActiveValue::unchanged(m.id),
            user_id: sea_orm::ActiveValue::unchanged(m.user_id),
            geometry: sea_orm::ActiveValue::unchanged(m.geometry),
            bounding_box: sea_orm::ActiveValue::unchanged(m.bounding_box),
            start_time: sea_orm::ActiveValue::unchanged(m.start_time),
            end_time: sea_orm::ActiveValue::unchanged(m.end_time),
            distance_meters: sea_orm::ActiveValue::unchanged(m.distance_meters),
            points: sea_orm::ActiveValue::unchanged(m.points),
            processed: sea_orm::ActiveValue::unchanged(m.processed),
            osm_way_ids: sea_orm::ActiveValue::unchanged(m.osm_way_ids),
            route_match_trace: sea_orm::ActiveValue::unchanged(m.route_match_trace),
            label: sea_orm::ActiveValue::unchanged(m.label),
            notes: sea_orm::ActiveValue::unchanged(m.notes),
            geo_json: sea_orm::ActiveValue::unchanged(m.geo_json),
            last_modified: sea_orm::ActiveValue::unchanged(m.last_modified),
        }
    }
}
#[automatically_derived]
impl sea_orm::IntoActiveModel<ActiveModel> for Model {
    fn into_active_model(self) -> ActiveModel {
        self.into()
    }
}
#[automatically_derived]
impl sea_orm::ActiveModelTrait for ActiveModel {
    type Entity = Entity;
    fn take(
        &mut self,
        c: <Self::Entity as sea_orm::EntityTrait>::Column,
    ) -> sea_orm::ActiveValue<sea_orm::Value> {
        match c {
            <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.id);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::UserId => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.user_id);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Geometry => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.geometry);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::BoundingBox => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.bounding_box);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::StartTime => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.start_time);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::EndTime => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.end_time);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::DistanceMeters => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.distance_meters);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Points => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.points);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Processed => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.processed);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::OsmWayIds => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.osm_way_ids);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::RouteMatchTrace => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.route_match_trace);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Label => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.label);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Notes => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.notes);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::GeoJson => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.geo_json);
                value.into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::LastModified => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.last_modified);
                value.into_wrapped_value()
            }
            _ => sea_orm::ActiveValue::not_set(),
        }
    }
    fn get(
        &self,
        c: <Self::Entity as sea_orm::EntityTrait>::Column,
    ) -> sea_orm::ActiveValue<sea_orm::Value> {
        match c {
            <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                self.id.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::UserId => {
                self.user_id.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Geometry => {
                self.geometry.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::BoundingBox => {
                self.bounding_box.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::StartTime => {
                self.start_time.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::EndTime => {
                self.end_time.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::DistanceMeters => {
                self.distance_meters.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Points => {
                self.points.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Processed => {
                self.processed.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::OsmWayIds => {
                self.osm_way_ids.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::RouteMatchTrace => {
                self.route_match_trace.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Label => {
                self.label.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Notes => {
                self.notes.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::GeoJson => {
                self.geo_json.clone().into_wrapped_value()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::LastModified => {
                self.last_modified.clone().into_wrapped_value()
            }
            _ => sea_orm::ActiveValue::not_set(),
        }
    }
    fn set(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column, v: sea_orm::Value) {
        match c {
            <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                self.id = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::UserId => {
                self.user_id = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Geometry => {
                self.geometry = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::BoundingBox => {
                self.bounding_box = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::StartTime => {
                self.start_time = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::EndTime => {
                self.end_time = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::DistanceMeters => {
                self.distance_meters = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Points => {
                self.points = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Processed => {
                self.processed = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::OsmWayIds => {
                self.osm_way_ids = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::RouteMatchTrace => {
                self.route_match_trace = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Label => {
                self.label = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Notes => {
                self.notes = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::GeoJson => {
                self.geo_json = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::LastModified => {
                self.last_modified = sea_orm::ActiveValue::set(v.unwrap());
            }
            _ => {
                panic!("This ActiveModel does not have this field");
            }
        }
    }
    fn not_set(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
        match c {
            <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                self.id = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::UserId => {
                self.user_id = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Geometry => {
                self.geometry = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::BoundingBox => {
                self.bounding_box = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::StartTime => {
                self.start_time = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::EndTime => {
                self.end_time = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::DistanceMeters => {
                self.distance_meters = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Points => {
                self.points = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Processed => {
                self.processed = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::OsmWayIds => {
                self.osm_way_ids = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::RouteMatchTrace => {
                self.route_match_trace = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Label => {
                self.label = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Notes => {
                self.notes = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::GeoJson => {
                self.geo_json = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::LastModified => {
                self.last_modified = sea_orm::ActiveValue::not_set();
            }
            _ => {}
        }
    }
    fn is_not_set(&self, c: <Self::Entity as sea_orm::EntityTrait>::Column) -> bool {
        match c {
            <Self::Entity as sea_orm::EntityTrait>::Column::Id => self.id.is_not_set(),
            <Self::Entity as sea_orm::EntityTrait>::Column::UserId => self.user_id.is_not_set(),
            <Self::Entity as sea_orm::EntityTrait>::Column::Geometry => self.geometry.is_not_set(),
            <Self::Entity as sea_orm::EntityTrait>::Column::BoundingBox => {
                self.bounding_box.is_not_set()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::StartTime => {
                self.start_time.is_not_set()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::EndTime => self.end_time.is_not_set(),
            <Self::Entity as sea_orm::EntityTrait>::Column::DistanceMeters => {
                self.distance_meters.is_not_set()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Points => self.points.is_not_set(),
            <Self::Entity as sea_orm::EntityTrait>::Column::Processed => {
                self.processed.is_not_set()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::OsmWayIds => {
                self.osm_way_ids.is_not_set()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::RouteMatchTrace => {
                self.route_match_trace.is_not_set()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Label => self.label.is_not_set(),
            <Self::Entity as sea_orm::EntityTrait>::Column::Notes => self.notes.is_not_set(),
            <Self::Entity as sea_orm::EntityTrait>::Column::GeoJson => self.geo_json.is_not_set(),
            <Self::Entity as sea_orm::EntityTrait>::Column::LastModified => {
                self.last_modified.is_not_set()
            }
            _ => {
                panic!("This ActiveModel does not have this field");
            }
        }
    }
    fn default() -> Self {
        Self {
            id: sea_orm::ActiveValue::not_set(),
            user_id: sea_orm::ActiveValue::not_set(),
            geometry: sea_orm::ActiveValue::not_set(),
            bounding_box: sea_orm::ActiveValue::not_set(),
            start_time: sea_orm::ActiveValue::not_set(),
            end_time: sea_orm::ActiveValue::not_set(),
            distance_meters: sea_orm::ActiveValue::not_set(),
            points: sea_orm::ActiveValue::not_set(),
            processed: sea_orm::ActiveValue::not_set(),
            osm_way_ids: sea_orm::ActiveValue::not_set(),
            route_match_trace: sea_orm::ActiveValue::not_set(),
            label: sea_orm::ActiveValue::not_set(),
            notes: sea_orm::ActiveValue::not_set(),
            geo_json: sea_orm::ActiveValue::not_set(),
            last_modified: sea_orm::ActiveValue::not_set(),
        }
    }
    fn reset(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
        match c {
            <Self::Entity as sea_orm::EntityTrait>::Column::Id => self.id.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::UserId => self.user_id.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::Geometry => self.geometry.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::BoundingBox => {
                self.bounding_box.reset()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::StartTime => self.start_time.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::EndTime => self.end_time.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::DistanceMeters => {
                self.distance_meters.reset()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Points => self.points.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::Processed => self.processed.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::OsmWayIds => self.osm_way_ids.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::RouteMatchTrace => {
                self.route_match_trace.reset()
            }
            <Self::Entity as sea_orm::EntityTrait>::Column::Label => self.label.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::Notes => self.notes.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::GeoJson => self.geo_json.reset(),
            <Self::Entity as sea_orm::EntityTrait>::Column::LastModified => {
                self.last_modified.reset()
            }
            _ => {
                panic!("This ActiveModel does not have this field");
            }
        }
    }
}
#[automatically_derived]
impl std::convert::TryFrom<ActiveModel> for Model {
    type Error = sea_orm::DbErr;
    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
        if match a.id {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("id".to_owned()));
        }
        if match a.user_id {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("user_id".to_owned()));
        }
        if match a.geometry {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("geometry".to_owned()));
        }
        if match a.bounding_box {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("bounding_box".to_owned()));
        }
        if match a.start_time {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("start_time".to_owned()));
        }
        if match a.end_time {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("end_time".to_owned()));
        }
        if match a.distance_meters {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("distance_meters".to_owned()));
        }
        if match a.points {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("points".to_owned()));
        }
        if match a.processed {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("processed".to_owned()));
        }
        if match a.osm_way_ids {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("osm_way_ids".to_owned()));
        }
        if match a.route_match_trace {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("route_match_trace".to_owned()));
        }
        if match a.label {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("label".to_owned()));
        }
        if match a.notes {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("notes".to_owned()));
        }
        if match a.geo_json {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("geo_json".to_owned()));
        }
        if match a.last_modified {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("last_modified".to_owned()));
        }
        Ok(Self {
            id: a.id.into_value().unwrap().unwrap(),
            user_id: a.user_id.into_value().unwrap().unwrap(),
            geometry: a.geometry.into_value().unwrap().unwrap(),
            bounding_box: a.bounding_box.into_value().unwrap().unwrap(),
            start_time: a.start_time.into_value().unwrap().unwrap(),
            end_time: a.end_time.into_value().unwrap().unwrap(),
            distance_meters: a.distance_meters.into_value().unwrap().unwrap(),
            points: a.points.into_value().unwrap().unwrap(),
            processed: a.processed.into_value().unwrap().unwrap(),
            osm_way_ids: a.osm_way_ids.into_value().unwrap().unwrap(),
            route_match_trace: a.route_match_trace.into_value().unwrap().unwrap(),
            label: a.label.into_value().unwrap().unwrap(),
            notes: a.notes.into_value().unwrap().unwrap(),
            geo_json: a.geo_json.into_value().unwrap().unwrap(),
            last_modified: a.last_modified.into_value().unwrap().unwrap(),
        })
    }
}
#[automatically_derived]
impl sea_orm::TryIntoModel<Model> for ActiveModel {
    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
        self.try_into()
    }
}

impl ActiveModelBehavior for ActiveModel {}
