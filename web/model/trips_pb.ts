// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file trips.proto (package chronotopia, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { DateTime, Point, RoadSegment, UUID } from "./common_pb.js";
import { ActivityEvent, VisitEvent } from "./ingest_pb.js";

/**
 * Trip model
 *
 * @generated from message chronotopia.Trip
 */
export class Trip extends Message<Trip> {
  /**
   * @generated from field: chronotopia.UUID id = 1;
   */
  id?: UUID;

  /**
   * @generated from field: chronotopia.DateTime start_time = 2;
   */
  startTime?: DateTime;

  /**
   * @generated from field: chronotopia.DateTime end_time = 3;
   */
  endTime?: DateTime;

  /**
   * @generated from field: double distance_meters = 4;
   */
  distanceMeters = 0;

  /**
   * @generated from field: repeated chronotopia.Point points = 5;
   */
  points: Point[] = [];

  /**
   * @generated from field: bool processed = 6;
   */
  processed = false;

  /**
   * @generated from field: repeated chronotopia.RoadSegment matched_segments = 7;
   */
  matchedSegments: RoadSegment[] = [];

  /**
   * @generated from field: string geojson = 8;
   */
  geojson = "";

  /**
   * @generated from field: repeated chronotopia.VisitEvent visits = 9;
   */
  visits: VisitEvent[] = [];

  /**
   * @generated from field: repeated chronotopia.ActivityEvent activities = 10;
   */
  activities: ActivityEvent[] = [];

  /**
   * @generated from field: optional string label = 11;
   */
  label?: string;

  /**
   * @generated from field: optional string notes = 12;
   */
  notes?: string;

  /**
   * @generated from field: optional chronotopia.RouteMatchTrace route_match_trace = 13;
   */
  routeMatchTrace?: RouteMatchTrace;

  constructor(data?: PartialMessage<Trip>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.Trip";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: UUID },
    { no: 2, name: "start_time", kind: "message", T: DateTime },
    { no: 3, name: "end_time", kind: "message", T: DateTime },
    { no: 4, name: "distance_meters", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "points", kind: "message", T: Point, repeated: true },
    { no: 6, name: "processed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "matched_segments", kind: "message", T: RoadSegment, repeated: true },
    { no: 8, name: "geojson", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "visits", kind: "message", T: VisitEvent, repeated: true },
    { no: 10, name: "activities", kind: "message", T: ActivityEvent, repeated: true },
    { no: 11, name: "label", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 12, name: "notes", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 13, name: "route_match_trace", kind: "message", T: RouteMatchTrace, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Trip {
    return new Trip().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Trip {
    return new Trip().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Trip {
    return new Trip().fromJsonString(jsonString, options);
  }

  static equals(a: Trip | PlainMessage<Trip> | undefined, b: Trip | PlainMessage<Trip> | undefined): boolean {
    return proto3.util.equals(Trip, a, b);
  }
}

/**
 * Trip list container
 *
 * @generated from message chronotopia.TripList
 */
export class TripList extends Message<TripList> {
  /**
   * @generated from field: repeated chronotopia.Trip trips = 1;
   */
  trips: Trip[] = [];

  constructor(data?: PartialMessage<TripList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.TripList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trips", kind: "message", T: Trip, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TripList {
    return new TripList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TripList {
    return new TripList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TripList {
    return new TripList().fromJsonString(jsonString, options);
  }

  static equals(a: TripList | PlainMessage<TripList> | undefined, b: TripList | PlainMessage<TripList> | undefined): boolean {
    return proto3.util.equals(TripList, a, b);
  }
}

/**
 * Import summary model
 *
 * @generated from message chronotopia.ImportSummary
 */
export class ImportSummary extends Message<ImportSummary> {
  /**
   * @generated from field: chronotopia.UUID id = 1;
   */
  id?: UUID;

  /**
   * @generated from field: string import_type = 2;
   */
  importType = "";

  /**
   * @generated from field: chronotopia.DateTime import_date_time = 3;
   */
  importDateTime?: DateTime;

  /**
   * @generated from field: uint32 location_count = 4;
   */
  locationCount = 0;

  /**
   * @generated from field: uint32 activity_count = 5;
   */
  activityCount = 0;

  /**
   * @generated from field: uint32 visit_count = 6;
   */
  visitCount = 0;

  /**
   * @generated from field: uint32 generated_trips = 7;
   */
  generatedTrips = 0;

  /**
   * @generated from field: bool processing_complete = 8;
   */
  processingComplete = false;

  /**
   * @generated from field: chronotopia.DateTime create_date_time = 9;
   */
  createDateTime?: DateTime;

  /**
   * @generated from field: string import_name = 10;
   */
  importName = "";

  /**
   * @generated from field: optional chronotopia.DateTime processed_date_time = 11;
   */
  processedDateTime?: DateTime;

  constructor(data?: PartialMessage<ImportSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.ImportSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: UUID },
    { no: 2, name: "import_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "import_date_time", kind: "message", T: DateTime },
    { no: 4, name: "location_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "activity_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "visit_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "generated_trips", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "processing_complete", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "create_date_time", kind: "message", T: DateTime },
    { no: 10, name: "import_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "processed_date_time", kind: "message", T: DateTime, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportSummary {
    return new ImportSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportSummary {
    return new ImportSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportSummary {
    return new ImportSummary().fromJsonString(jsonString, options);
  }

  static equals(a: ImportSummary | PlainMessage<ImportSummary> | undefined, b: ImportSummary | PlainMessage<ImportSummary> | undefined): boolean {
    return proto3.util.equals(ImportSummary, a, b);
  }
}

/**
 * Processing state model
 *
 * @generated from message chronotopia.TripProcessingState
 */
export class TripProcessingState extends Message<TripProcessingState> {
  /**
   * @generated from field: chronotopia.DateTime last_processed_time = 1;
   */
  lastProcessedTime?: DateTime;

  /**
   * @generated from field: uint32 total_trips_generated = 2;
   */
  totalTripsGenerated = 0;

  /**
   * @generated from field: uint32 total_visits_detected = 3;
   */
  totalVisitsDetected = 0;

  /**
   * @generated from field: chronotopia.DateTime last_updated = 4;
   */
  lastUpdated?: DateTime;

  constructor(data?: PartialMessage<TripProcessingState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.TripProcessingState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "last_processed_time", kind: "message", T: DateTime },
    { no: 2, name: "total_trips_generated", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "total_visits_detected", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "last_updated", kind: "message", T: DateTime },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TripProcessingState {
    return new TripProcessingState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TripProcessingState {
    return new TripProcessingState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TripProcessingState {
    return new TripProcessingState().fromJsonString(jsonString, options);
  }

  static equals(a: TripProcessingState | PlainMessage<TripProcessingState> | undefined, b: TripProcessingState | PlainMessage<TripProcessingState> | undefined): boolean {
    return proto3.util.equals(TripProcessingState, a, b);
  }
}

/**
 * Request to get trips for a user
 *
 * @generated from message chronotopia.GetTripsForUserRequest
 */
export class GetTripsForUserRequest extends Message<GetTripsForUserRequest> {
  /**
   * @generated from field: uint32 limit = 1;
   */
  limit = 0;

  /**
   * @generated from field: optional chronotopia.DateTime from_date = 2;
   */
  fromDate?: DateTime;

  /**
   * @generated from field: optional chronotopia.DateTime to_date = 3;
   */
  toDate?: DateTime;

  constructor(data?: PartialMessage<GetTripsForUserRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.GetTripsForUserRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "from_date", kind: "message", T: DateTime, opt: true },
    { no: 3, name: "to_date", kind: "message", T: DateTime, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTripsForUserRequest {
    return new GetTripsForUserRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTripsForUserRequest {
    return new GetTripsForUserRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTripsForUserRequest {
    return new GetTripsForUserRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetTripsForUserRequest | PlainMessage<GetTripsForUserRequest> | undefined, b: GetTripsForUserRequest | PlainMessage<GetTripsForUserRequest> | undefined): boolean {
    return proto3.util.equals(GetTripsForUserRequest, a, b);
  }
}

/**
 * Response with user's trips
 *
 * @generated from message chronotopia.GetTripsForUserResponse
 */
export class GetTripsForUserResponse extends Message<GetTripsForUserResponse> {
  /**
   * @generated from field: chronotopia.TripList trips = 1;
   */
  trips?: TripList;

  constructor(data?: PartialMessage<GetTripsForUserResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.GetTripsForUserResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trips", kind: "message", T: TripList },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTripsForUserResponse {
    return new GetTripsForUserResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTripsForUserResponse {
    return new GetTripsForUserResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTripsForUserResponse {
    return new GetTripsForUserResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetTripsForUserResponse | PlainMessage<GetTripsForUserResponse> | undefined, b: GetTripsForUserResponse | PlainMessage<GetTripsForUserResponse> | undefined): boolean {
    return proto3.util.equals(GetTripsForUserResponse, a, b);
  }
}

/**
 * Response with processing state
 *
 * @generated from message chronotopia.GetUserProcessingStateResponse
 */
export class GetUserProcessingStateResponse extends Message<GetUserProcessingStateResponse> {
  /**
   * @generated from field: chronotopia.TripProcessingState state = 1;
   */
  state?: TripProcessingState;

  /**
   * @generated from field: repeated chronotopia.ImportSummary imports = 2;
   */
  imports: ImportSummary[] = [];

  constructor(data?: PartialMessage<GetUserProcessingStateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.GetUserProcessingStateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: TripProcessingState },
    { no: 2, name: "imports", kind: "message", T: ImportSummary, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUserProcessingStateResponse {
    return new GetUserProcessingStateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUserProcessingStateResponse {
    return new GetUserProcessingStateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUserProcessingStateResponse {
    return new GetUserProcessingStateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetUserProcessingStateResponse | PlainMessage<GetUserProcessingStateResponse> | undefined, b: GetUserProcessingStateResponse | PlainMessage<GetUserProcessingStateResponse> | undefined): boolean {
    return proto3.util.equals(GetUserProcessingStateResponse, a, b);
  }
}

/**
 * Response after triggering processing
 *
 * @generated from message chronotopia.TriggerProcessingResponse
 */
export class TriggerProcessingResponse extends Message<TriggerProcessingResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<TriggerProcessingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.TriggerProcessingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TriggerProcessingResponse {
    return new TriggerProcessingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TriggerProcessingResponse {
    return new TriggerProcessingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TriggerProcessingResponse {
    return new TriggerProcessingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TriggerProcessingResponse | PlainMessage<TriggerProcessingResponse> | undefined, b: TriggerProcessingResponse | PlainMessage<TriggerProcessingResponse> | undefined): boolean {
    return proto3.util.equals(TriggerProcessingResponse, a, b);
  }
}

/**
 * Request to get trip details
 *
 * @generated from message chronotopia.TripReference
 */
export class TripReference extends Message<TripReference> {
  /**
   * @generated from field: chronotopia.UUID trip_id = 1;
   */
  tripId?: UUID;

  constructor(data?: PartialMessage<TripReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.TripReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trip_id", kind: "message", T: UUID },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TripReference {
    return new TripReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TripReference {
    return new TripReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TripReference {
    return new TripReference().fromJsonString(jsonString, options);
  }

  static equals(a: TripReference | PlainMessage<TripReference> | undefined, b: TripReference | PlainMessage<TripReference> | undefined): boolean {
    return proto3.util.equals(TripReference, a, b);
  }
}

/**
 * Response with trip details
 *
 * @generated from message chronotopia.GetTripDetailsResponse
 */
export class GetTripDetailsResponse extends Message<GetTripDetailsResponse> {
  /**
   * @generated from field: chronotopia.Trip trip = 1;
   */
  trip?: Trip;

  constructor(data?: PartialMessage<GetTripDetailsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.GetTripDetailsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trip", kind: "message", T: Trip },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTripDetailsResponse {
    return new GetTripDetailsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTripDetailsResponse {
    return new GetTripDetailsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTripDetailsResponse {
    return new GetTripDetailsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetTripDetailsResponse | PlainMessage<GetTripDetailsResponse> | undefined, b: GetTripDetailsResponse | PlainMessage<GetTripDetailsResponse> | undefined): boolean {
    return proto3.util.equals(GetTripDetailsResponse, a, b);
  }
}

/**
 * @generated from message chronotopia.PointConstraint
 */
export class PointConstraint extends Message<PointConstraint> {
  /**
   * @generated from field: uint32 point_idx = 1;
   */
  pointIdx = 0;

  /**
   * @generated from field: uint64 segment_id = 2;
   */
  segmentId = protoInt64.zero;

  /**
   * @generated from field: uint64 way_id = 3;
   */
  wayId = protoInt64.zero;

  /**
   * @generated from field: double distance = 4;
   */
  distance = 0;

  constructor(data?: PartialMessage<PointConstraint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.PointConstraint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "point_idx", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "segment_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "way_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "distance", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointConstraint {
    return new PointConstraint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointConstraint {
    return new PointConstraint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointConstraint {
    return new PointConstraint().fromJsonString(jsonString, options);
  }

  static equals(a: PointConstraint | PlainMessage<PointConstraint> | undefined, b: PointConstraint | PlainMessage<PointConstraint> | undefined): boolean {
    return proto3.util.equals(PointConstraint, a, b);
  }
}

/**
 * @generated from message chronotopia.WindowTrace
 */
export class WindowTrace extends Message<WindowTrace> {
  /**
   * @generated from field: uint32 start = 1;
   */
  start = 0;

  /**
   * @generated from field: uint32 end = 2;
   */
  end = 0;

  /**
   * @generated from field: repeated chronotopia.RoadSegment segments = 3;
   */
  segments: RoadSegment[] = [];

  /**
   * @generated from field: bool bridge = 4;
   */
  bridge = false;

  /**
   * @generated from field: repeated chronotopia.PointConstraint constraints = 5;
   */
  constraints: PointConstraint[] = [];

  /**
   * @generated from field: bool used_constraints = 6;
   */
  usedConstraints = false;

  /**
   * @generated from field: optional double constraint_score = 7;
   */
  constraintScore?: number;

  /**
   * @generated from field: optional double unconstrained_score = 8;
   */
  unconstrainedScore?: number;

  /**
   * @generated from field: repeated uint64 attempted_way_ids = 9;
   */
  attemptedWayIds: bigint[] = [];

  /**
   * @generated from field: repeated string debug_notes = 10;
   */
  debugNotes: string[] = [];

  constructor(data?: PartialMessage<WindowTrace>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.WindowTrace";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "end", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "segments", kind: "message", T: RoadSegment, repeated: true },
    { no: 4, name: "bridge", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "constraints", kind: "message", T: PointConstraint, repeated: true },
    { no: 6, name: "used_constraints", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "constraint_score", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 8, name: "unconstrained_score", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 9, name: "attempted_way_ids", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
    { no: 10, name: "debug_notes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowTrace {
    return new WindowTrace().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowTrace {
    return new WindowTrace().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowTrace {
    return new WindowTrace().fromJsonString(jsonString, options);
  }

  static equals(a: WindowTrace | PlainMessage<WindowTrace> | undefined, b: WindowTrace | PlainMessage<WindowTrace> | undefined): boolean {
    return proto3.util.equals(WindowTrace, a, b);
  }
}

/**
 * @generated from message chronotopia.RouteMatchTrace
 */
export class RouteMatchTrace extends Message<RouteMatchTrace> {
  /**
   * @generated from field: repeated chronotopia.WindowTrace windowTraces = 1;
   */
  windowTraces: WindowTrace[] = [];

  /**
   * @generated from field: repeated string pointCandidates = 2;
   */
  pointCandidates: string[] = [];

  constructor(data?: PartialMessage<RouteMatchTrace>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "chronotopia.RouteMatchTrace";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "windowTraces", kind: "message", T: WindowTrace, repeated: true },
    { no: 2, name: "pointCandidates", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteMatchTrace {
    return new RouteMatchTrace().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteMatchTrace {
    return new RouteMatchTrace().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteMatchTrace {
    return new RouteMatchTrace().fromJsonString(jsonString, options);
  }

  static equals(a: RouteMatchTrace | PlainMessage<RouteMatchTrace> | undefined, b: RouteMatchTrace | PlainMessage<RouteMatchTrace> | undefined): boolean {
    return proto3.util.equals(RouteMatchTrace, a, b);
  }
}

